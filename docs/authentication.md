# ユーザー認証仕様書

## 1. 概要

本アプリケーションのユーザー認証は、[Supabase Auth](https://supabase.com/docs/guides/auth) を全面的に利用して実装する。これにより、安全かつスケーラブルな認証システムを迅速に構築する。

- **認証基盤**: Supabase Auth
- **認証方法**: サードパーティプロバイダーによるソーシャルログイン
- **ユーザー識別**: すべてのユーザーは `auth.users` テーブルに格納され、一意の `UUID` によって識別される。
- **権限管理**: データベースのアクセス制御には、行単位セキュリティ（RLS）と `auth.uid()` 関数を組み合わせて利用する。

---

## 2. 認証プロバイダー

要件（F-001）に基づき、以下のソーシャルログインプロバイダーをサポートする。

- **Google**: 一般的なユーザー向け
- **GitHub**: 開発者ユーザー向け

これらのプロバイダーはSupabaseの管理画面から設定され、クライアント側はSupabaseのSDK経由で認証を開始する。

---

## 3. ユーザー登録フロー（新規サインアップ）

1.  ユーザーがクライアントアプリ（フロントエンド）で「Googleでログイン」または「GitHubでログイン」ボタンをクリックする。
2.  クライアントはSupabase Authの `signInWithOAuth()` メソッドを呼び出し、選択されたプロバイダーを指定する。
3.  ユーザーはプロバイダー（Google/GitHub）の認証画面にリダイレクトされ、認証とアプリへのアクセス許可を行う。
4.  認証が成功すると、プロバイダーはSupabase Authのエンドポイントにコールバックする。
5.  Supabase Authは新しいユーザーを `auth.users` テーブルに自動的に作成する。この時、一意の `UUID` が `id` として割り当てられる。
6.  **トリガー発火**: `auth.users` テーブルに新しいレコードが挿入されると、PostgreSQLのトリガー `on_auth_user_created` が発火する。
7.  **`public.users` への反映**: トリガーは `handle_new_user` 関数を呼び出す。この関数は、`auth.users` から新しいユーザーの `id`, `full_name`, `avatar_url` などを取得し、`public.users` テーブルに対応するレコードを作成する。これにより、アプリケーションの他データとの関連付けが可能になる。
8.  クライアントはセッション情報（JWT）を受け取り、ログイン状態となる。

---

## 4. ログインフロー（既存ユーザー）

フローは基本的に新規サインアップと同じ。

1.  ユーザーが「Googleでログイン」などをクリック。
2.  `signInWithOAuth()` が呼び出される。
3.  プロバイダーでの認証後、Supabase Authは `auth.users` テーブルに既存のユーザーが存在することを検出し、新しいレコードは作成しない。
4.  クライアントは新しいセッション情報（JWT）を受け取り、ログイン状態となる。`public.users` テーブルへの変更はない。

---

## 5. セッション管理

- **トークン形式**: 認証にはJSON Web Tokens (JWT) を使用する。
- **保管場所**: JWTはクライアント側（ブラウザ）の `localStorage` または `sessionStorage` に安全に保管される。Supabaseのクライアントライブラリがこれを自動で管理する。
- **有効期限**:
    - **アクセストークン**: 短命（デフォルト1時間）。データベースへのリクエスト毎にAPI Gatewayで検証される。
    - **リフレッシュトークン**: 長命。アクセストークンの有効期限が切れた際に、新しいアクセストークンを自動で再取得するために使用される。
- **ログアウト**: クライアントが `signOut()` メソッドを呼び出すと、Supabase Authはセッションを無効化し、クライアントからJWTを削除する。

---

## 6. 権限管理（RLSとの連携）

本システムのセキュリティは、PostgreSQLの行単位セキュリティ（Row Level Security, RLS）を基本とする。

- **基本原則**: **デフォルトですべてを拒否**。すべてのテーブルはRLSが有効化されており、明示的に許可されたポリシーがない限り、データへのアクセスは一切できない。
- **ユーザー識別のための関数**: ポリシーを定義する際には、`auth.uid()` 関数を使用する。この関数は、リクエストを行っている認証済みユーザーの `UUID` を返す。
- **ポリシーの例**: `bookmarks` テーブルのRLSポリシー
    ```sql
    -- 自分のブックマークのみ閲覧・操作を許可するポリシー
    CREATE POLICY "Enable full access for users based on user_id"
    ON "public"."bookmarks"
    AS PERMISSIVE FOR ALL
    TO public
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id)
    ```
    このポリシーにより、ユーザーは `bookmarks` テーブル内の `user_id` カラムが自身の `UUID` と一致する行しか見たり、操作したりすることができなくなる。

これにより、他のユーザーのデータを誤って（あるいは悪意を持って）参照・変更することをデータベースレベルで完全に防ぐ。 